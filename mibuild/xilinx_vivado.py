import os, struct, subprocess, sys
from decimal import Decimal

from migen.fhdl.std import *
from migen.fhdl.specials import SynthesisDirective
from migen.genlib.cdc import *
from migen.fhdl.structure import _Fragment

from mibuild.generic_platform import *
from mibuild.crg import SimpleCRG
from mibuild import tools

# UCF is not supported in Vivado, and there are far more specific constraints for XDC/SDC.

# TODO:
#	- Add most common physical/placement constraint functions (Timing is very comoplex in Vivado)
#	- Clean up Synthesis/Implementation classes (settings in ISE do not map to Vivado)
#	- Add functionality to have it work on Windows without cygwin
#	- Add checkpoint functionality for project-less flow

def _create_clock_constraint(platform, clk, period):
	if period is not None:
		# Default duty cycle is always 50%
		platform.add_platform_command("""create_clock -period """ + str(period) + """ -name {clk} [get_clocks {clk}]""", clk=clk)

class CRG_SE(SimpleCRG):
	def __init__(self, platform, clk_name, rst_name, period=None, rst_invert=False):
		SimpleCRG.__init__(self, platform, clk_name, rst_name, rst_invert)
		_add_period_constraint(platform, self._clk, period)

class CRG_DS(Module):
	def __init__(self, platform, clk_name, rst_name, period=None, rst_invert=False):
		reset_less = rst_name is None
		self.clock_domains.cd_sys = ClockDomain(reset_less=reset_less)
		self._clk = platform.request(clk_name)
		_add_period_constraint(platform, self._clk.p, period)
		self.specials += Instance("IBUFGDS",
			Instance.Input("I", self._clk.p),
			Instance.Input("IB", self._clk.n),
			Instance.Output("O", self.cd_sys.clk)
		)
		if not reset_less:
			if rst_invert:
				self.comb += self.cd_sys.rst.eq(~platform.request(rst_name))
			else:
				self.comb += self.cd_sys.rst.eq(platform.request(rst_name))

# Formatting for TCL syntax
def _format_constraint(c):
	if isinstance(c, Pins):
		return "PACKAGE_PIN " + c.identifiers[0]
	elif isinstance(c, IOStandard):
		return "IOSTANDARD " + c.name
	elif isinstance(c, Drive):
		return "DRIVE " + str(c.strength)
	elif isinstance(c, Misc):
		return c.misc

def _format_xdc(signame, pin, others, resname):
	fmt_c = []
	for c in [Pins(pin)] + others:
		fc = _format_constraint(c)
		if fc is not None:
			fmt_c.append(fc)
	fmt_r = resname[0] + ":" + str(resname[1])
	if resname[2] is not None:
		fmt_r += "." + resname[2]
	#return "NET \"" + signame + "\" " + " | ".join(fmt_c) + "; # " + fmt_r + "\n"
	return "set_property " + fmt_c + " " + fmt_r + " [get_ports " + signame + " ]"

def _is_valid_version(path, v):
	try: 
		Decimal(v)
		return os.path.isdir(os.path.join(path, v))
	except:
		return False

def _run_vivado(build_name, vivado_path, source, mode, vivado_commands):
	if sys.platform == "win32" or sys.platform == "cygwin":
		source = False
	build_script_contents = "# Autogenerated by mibuild\nset -e\n"
	if source:
		vers = [ver for ver in os.listdir(vivado_path) if _is_valid_version(vivado_path, ver)]
		tools_version = max(vers)
		bits = struct.calcsize("P")*8
		
		xilinx_settings_file = os.path.join(vivado_path, tools_version, "settings{0}.sh".format(bits))
		if not os.path.exists(xilinx_settings_file) and bits == 64:
			# if we are on 64-bit system but the toolchain isn't, try the 32-bit env.
			xilinx_settings_file = os.path.join(vivado_path, tools_version,, "settings32.sh")
		build_script_contents += "source " + xilinx_settings_file + "\n"

		# Vivado has TCL/Batch mode.
	if r != 0:
		raise OSError("Subprocess failed")

# Clean up for Vivado (ISE functionality does not work in Vivado)
class XilinxNoRetimingImpl(Module):
	def __init__(self, reg):
		self.specials += SynthesisDirective("attribute register_balancing of {r} is no", r=reg)

# Clean up for Vivado
class XilinxNoRetiming:
	@staticmethod
	def lower(dr):
		return XilinxNoRetimingImpl(dr.reg)

# Clean up for Vivado
class XilinxMultiRegImpl(MultiRegImpl):
	def __init__(self, *args, **kwargs):
		MultiRegImpl.__init__(self, *args, **kwargs)
		self.specials += [SynthesisDirective("attribute shreg_extract of {r} is no", r=r)
			for r in self.regs]

# Clean up for Vivado
class XilinxMultiReg:
	@staticmethod
	def lower(dr):
		return XilinxMultiRegImpl(dr.i, dr.o, dr.odomain, dr.n)

# Clean up for Vivado
class XilinxVivadoPlatform(GenericPlatform):
	vivado_commands = ""
	def get_verilog(self, *args, special_overrides=dict(), **kwargs):
		so = {
			NoRetiming: XilinxNoRetiming,
			MultiReg:   XilinxMultiReg
		}
		so.update(special_overrides)
		return GenericPlatform.get_verilog(self, *args, special_overrides=so, **kwargs)

	def get_edif(self, fragment, **kwargs):
		return GenericPlatform.get_edif(self, fragment, "UNISIMS", "Xilinx", self.device, **kwargs)

	def build(self, fragment, build_dir="build", build_name="top",
			ise_path="/opt/Xilinx", source=True, run=True, mode="xst"):
		tools.mkdir_noerror(build_dir)
		os.chdir(build_dir)

		if not isinstance(fragment, _Fragment):
			fragment = fragment.get_fragment()
		self.finalize(fragment)

		ngdbuild_opt = self.ngdbuild_opt

		if mode == "xst" or mode == "yosys":
			v_src, named_sc, named_pc = self.get_verilog(fragment)
			v_file = build_name + ".v"
			tools.write_to_file(v_file, v_src)
			sources = self.sources + [(v_file, "verilog")]
			if mode == "xst":
				_build_xst_files(self.device, sources, self.verilog_include_paths, build_name, self.xst_opt)
				isemode = "xst"
			else:
				_run_yosys(self.device, sources, self.verilog_include_paths, build_name)
				isemode = "edif"
				ngdbuild_opt += "-p " + self.device

		if mode == "mist":
			from mist import synthesize
			synthesize(fragment, self.constraint_manager.get_io_signals())

		if mode == "edif" or mode == "mist":
			e_src, named_sc, named_pc = self.get_edif(fragment)
			e_file = build_name + ".edif"
			tools.write_to_file(e_file, e_src)
			isemode = "edif"

		tools.write_to_file(build_name + ".ucf", _build_ucf(named_sc, named_pc))
		if run:
			_run_ise(build_name, ise_path, source, isemode,
					ngdbuild_opt, self.bitgen_opt, self.ise_commands)

		os.chdir("..")
